% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ppm_predict.R
\name{predict.ppmFit}
\alias{predict.ppmFit}
\title{predict a ppmFit model}
\usage{
\method{predict}{ppmFit}(
  object,
  newdata = NULL,
  cvobject = NULL,
  offset = NULL,
  type = c("response", "link"),
  slambda = c("lambda.min", "lambda.1se"),
  quad.only = FALSE,
  filename = NULL,
  control = list(),
  ...
)
}
\arguments{
\item{object}{A fitted ppmFit object as fitted using \link{ppmFit}[ppmFit].}

\item{newdata}{Either a SpatRaster stack with the same data as those in the model; a character string which points to a path which contains tiles as created using \link{ppmFit}[createPredTiles] or a data.frame}

\item{cvobject}{A cvLambda object. If NULL (default) the prediction will be calculated as the average of all lambda predictions.}

\item{offset}{Either a SpatRaster with an offset that will be used in the model; a character string which points to a path which contains a tiled version of the offset created using \link{ppmFit}[createPredTiles] or numeric vector.}

\item{type}{Character. Either "response","link" or "unit". The type of response variable to return. The default is 'response' which is on the intensity scale or 'link' which is one the linear predictor scale (log). Unit scales the intensity (response) by the area of each cell/prediction point.}

\item{slambda}{Character Either 'lambda.min' or 'lambda.1se'. Value(s) of the penalty parameter lambda at which predictions are required. Default is "lambda.min".}

\item{quad.only}{Logical. If TRUE prediction is only done at the quadrature locations - useful for some of the diagnostic tools. Only works if cvobject is passed to the prediction function.}

\item{control}{list A list of control options for tiling. See the details below.}

\item{\\dots}{dots. Not used, but needed for prediction function.}
}
\description{
This function should predict an intensity surface based on the
on the model fitting in the ppmFit.
}
\details{
For very large rasters we can use tiling and parallel processing to do predictions.
This is for making prediction for high resolution or at broad spatial scales.
There a bunch of control arguments for running prediction using tiles can be passed as
follows to predict:
\describe{
 \item{predictionFile}{The path and file name of the prediction raster to be saved. Default is 'prediction.tif' and will be save in the current working directory.}
 \item{returnRaster}{Default is TRUE; leave this one alone unless you are using the predictWithTiles function on it's own}
 \item{tileFiles}{Name of the tile files, default is 'tile' and this will generate 'tile1.tif' to 'tileN.tif' where N is the total number of tiles to be generated.}
 \item{tilesDir}{The directory to store the tiles; default is a folder called 'tiles'}
 \item{vrtFile}{The vrt file needed to stitch together the files. Default is 'tmp.vrt'}
 \item{deleteTmp}{Should all the tmp files created as part of the tiling? Default is TRUE, can turn this off for trouble shooting}
 \item{predsDir}{The directory to hold the tmp prediction tiles. Default is "preds"}
 \item{mc.cores}{The number of cores to use when doing the tiles prediction. Default is 1, this will result in sequencial prediction per tile. If mc.cores > 1 tile prediction will be done in parallel.}
 }
}
\examples{
\dontrun{
library(ppmData)
library(ppmFit)
library(terra)
path <- system.file("extdata", package = "ppmData")
lst <- list.files(path=path,pattern='*.tif',full.names = TRUE)
covariates <- rast(lst)
s <- sum(covariates)
covariates <- mask(covariates,s)
bias <- covariates[[1]]
names(bias) <- "bias"
covariates <- c(covariates,bias)
presences <- subset(snails,SpeciesID \%in\% "Tasmaphena sinclairi")

ppmdata <- ppmData(npoints = 10000,
                  presences=presences,
                  window = covariates[[1]],
                  covariates = covariates)

sp_form <- presence ~ poly(annual_mean_precip,2,raw=TRUE) +
                     poly(annual_mean_temp,2,raw=TRUE) +
                     poly(distance_from_main_roads,2,raw=TRUE)

## Fit a ppm using glmnet lasso
ft.ppm <- ppmFit(species_formula = sp_form, ppmdata=ppmdata)

## predict to the SpatRaster object
pred1 <- predict(ft.ppm, covariates)

## prediction using tiles (for large rasters)
pred2 <- predict(ft.ppm, covariates, control=list(mc.cores=3))

## predict to presence & quadrature sites
pred3 <- predict(ft.ppm)

## predict to just the quadrature sites
pred4 <- predict(ft.ppm, quad.only=TRUE)}
}
