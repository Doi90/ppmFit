% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ppm_predict.R
\name{predict.ppmFit}
\alias{predict.ppmFit}
\title{predict a ppmFit model}
\usage{
\method{predict}{ppmFit}(
  object,
  cvobject = NULL,
  newdata = NULL,
  type = c("response", "link"),
  offset = NULL,
  slambda = c("lambda.min", "lambda.1se"),
  bias.correct = FALSE,
  quad.only = TRUE,
  filename = NULL,
  bigtif = FALSE,
  control = list(),
  ...
)
}
\arguments{
\item{object}{A fitted ppmFit object.}

\item{newdata}{SpatRaster. A terra raster stack of covariates for the model, or it can be a data.frame.}

\item{type}{Character. Either "response","link" or "unit". The type of response variable to return. The default is 'response' which is on the intensity scale or 'link' which is one the linear predictor scale (log). Unit scales the intensity (response) by the area of each cell/prediction point.}

\item{offset}{Numeric vector or raster. If an offset is used in the model. Either an observed offset at prediction sites. If an offset is used and this is not known at prediction sites something like the mean offset used to fit the model can be used.}

\item{slambda}{Character Either 'lambda.min' or 'lambda.1se'. Value(s) of the penalty parameter lambda at which predictions are required. Default is "lambda.min".}

\item{quad.only}{Logical. If TRUE prediction is only done at the quadrature locations - useful for some of the diagnostic tools.}

\item{filename}{String Name of the raster file and path to save prediction. Default is NULL, otherwise it needs to be something like "pred.tif"}

\item{bigtif}{bool if TRUE it will try and do prediction via tiling, this will be slower but
will help with large tifs where holding the entire raster stack in memory is inpractical.}

\item{control}{list A list of control options for tiling. See the details below.}

\item{cores}{Integer. The number of cores to use in the prediction, useful for large rasters.}

\item{\\dots}{dots. Not used, but needed for prediction function.}
}
\description{
This function should predict an intensity surface based on the
on the model fitting in the ppmFit.
}
\details{
For every large raster we can use tiling and parallel processing to do predictions
This is useful when making point process prediction for high resolution or broad scale rasters.
There a bunch of control arguments for running prediction using tiles can be passed as
follows to predict:
\describe{
 \item{predictionFile}{The path and file name of the prediction raster to be saved. Default is 'prediction.tif' and will be save in the current working directory.}
 \item{returnRaster}{Default is TRUE; leave this one alone unless you are using the predictWithTiles function on it's own}
 \item{tileFiles}{Name of the tile files, default is 'tile' and this will generate 'tile1.tif' to 'tileN.tif' where N is the total number of tiles to be generated.}
 \item{tilesDir}{The directory to store the tiles; default is a folder called 'tiles'}
 \item{vrtFile}{The vrt file needed to stitch together the files. Default is 'tmp.vrt'}
 \item{cacheTiles}{Should the covariate tiles created for prediction be cached? Default is FALSE. If TRUE the tiles used to generate the predictions will not be deleted once the function is finished. This means a user can reuse them for future predictions and skip the creation of tiles step.}
 \item{deleteTmp}{Will R delete all the tmp files created as part of the tiling? Default is TRUE. If false all input tiles, prediction tiles and vrt files will be retained. If cacheTiles is used then the input (covariate tiles) will be retained.}
 \item{ntiles}{The number of tiles to use across rows or columns, default is 10, which result in 100 tiles (10*10).}
 \item{mc.cores}{The number of cores to use when doing the tiles prediction. Default is 1, this will result in sequencial prediction per tile. If mc.cores > 1 tile prediction will be done in parallel.}
 }
}
\examples{
\dontrun{
library(ppmData)
library(ppmFit)
library(terra)
path <- system.file("extdata", package = "ppmData")
lst <- list.files(path=path,pattern='*.tif',full.names = TRUE)
covariates <- rast(lst)
s <- sum(covariates)
covariates <- mask(covariates,s)
bias <- covariates[[1]]
names(bias) <- "bias"
covariates <- c(covariates,bias)
presences <- subset(snails,SpeciesID \%in\% "Tasmaphena sinclairi")

ppmdata <- ppmData(npoints = 10000,
                  presences=presences,
                  window = covariates[[1]],
                  covariates = covariates)

sp_form <- presence ~ poly(annual_mean_precip,2,raw=TRUE) +
                     poly(annual_mean_temp,2,raw=TRUE) +
                     poly(distance_from_main_roads,2,raw=TRUE)

## Fit a ppm using glmnet lasso
ft.ppm <- ppmFit(species_formula = sp_form, ppmdata=ppmdata)

## predict to the SpatRaster object
pred1 <- predict(ft.ppm, covariates)

## prediction using tiles (for large rasters)
pred2 <- predict(ft.ppm, covariates, bigtif=TRUE, control=list(mc.cores=6))

## predict to presence & quadrature sites
pred4 <- predict(ft.ppm)

## predict to just the quadrature sites
pred5 <- predict(ft.ppm, quad.only=TRUE)}
}
